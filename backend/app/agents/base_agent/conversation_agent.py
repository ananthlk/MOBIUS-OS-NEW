"""
Base conversation agent
- Captures user message
- Replays user message (echo back)
- Sends acknowledgement
- Uses session_id from frontend
"""

from datetime import datetime


class ConversationAgent:
    """
    Base conversation agent
    - Captures user message
    - Replays user message (echo back)
    - Sends acknowledgement
    - Uses session_id from frontend
    """
    
    # Canonical UI component keys (27) as defined in `components-list.md`
    UI_COMPONENT_KEYS = [
        "clientLogo",
        "mobiusLogo",
        "statusIndicator",
        "modeBadge",
        "alertButton",
        "settingsButton",
        "contextDisplay",
        "contextSummary",
        "quickActionButton",
        "tasksPanel",
        "taskItem",
        "thinkingBox",
        "systemMessage",
        "userMessage",
        "feedbackComponent",
        "guidanceActions",
        "chatInput",
        "chatTools",
        "recordIdInput",
        "workflowButtons",
        "userDetails",
        "preferencesPanel",
        "chatMessage",
        "header",
        "chatArea",
        "collapsiblePanel",
        "dropdownMenu",
    ]

    def get_ui_defaults_for_mode(self, mode: str | None = None) -> dict:
        """
        Mode-aware default UI visibility.

        Note: The client is the source of truth for UI layout; the backend should generally only
        send per-message ui_overrides. This helper exists for parity/future use.
        """
        base = {key: True for key in self.UI_COMPONENT_KEYS}
        normalized = (mode or "").strip().lower()

        # v1: only Chat. Extend this dict as new backend modes are introduced.
        per_mode_overrides: dict[str, dict] = {
            "chat": {
                # Default: feedback UI off unless enabled per-message.
                "feedbackComponent": False,
            }
        }

        overrides = per_mode_overrides.get(normalized) or {}
        base.update(overrides)
        return base

    def get_ui_defaults(self) -> dict:
        """
        Default UI visibility: all components visible.
        Mode-specific agents can override per-message via `ui_overrides`.
        """
        return {key: True for key in self.UI_COMPONENT_KEYS}

    def build_message(self, kind: str, content: str, ui_overrides: dict | None = None) -> dict:
        """Build a structured message payload with UI overrides."""
        return {
            "kind": kind,
            "content": content,
            "ui_overrides": ui_overrides or {},
        }

    def process_message(
        self,
        user_message: str,
        session_id: str,
        context: dict | None = None,
        per_message_ui_overrides: dict | None = None,
    ):
        """
        Process user message
        Args:
            user_message: User's message
            session_id: Session ID generated by frontend
            context: Optional context dict
            per_message_ui_overrides: optional dict keyed by message kind -> dict of ui overrides
        Returns: dict with replayed message and acknowledgement
        """
        if context is None:
            context = {}
        
        # Validate session_id
        if not session_id:
            raise ValueError("session_id is required")
        
        # 1. Capture user message (with session_id)
        captured = self._capture_message(user_message, session_id, context)
        
        # 2. Replay user message
        replayed = self._replay_message(user_message)
        
        # 3. Send acknowledgement
        acknowledgement = self._send_acknowledgement(user_message)

        # UI visibility defaults + per-message overrides (defaults+overrides pattern)
        ui_defaults = self.get_ui_defaults()
        per_message_ui_overrides = per_message_ui_overrides or {}

        # Default rule: echo and acknowledgement should not show feedback UI.
        base_no_feedback = {"feedbackComponent": False}

        replayed_overrides = dict(base_no_feedback)
        replayed_overrides.update(per_message_ui_overrides.get("replayed") or {})

        acknowledgement_overrides = dict(base_no_feedback)
        acknowledgement_overrides.update(per_message_ui_overrides.get("acknowledgement") or {})

        messages = [
            self.build_message("replayed", replayed, replayed_overrides),
            self.build_message("acknowledgement", acknowledgement, acknowledgement_overrides),
        ]
        
        return {
            "success": True,
            "session_id": session_id,
            "replayed": replayed,
            "acknowledgement": acknowledgement,
            "captured": captured,
            "ui_defaults": ui_defaults,
            "messages": messages,
        }
    
    def _capture_message(self, user_message: str, session_id: str, context: dict):
        """Capture and store user message"""
        # For now, just return confirmation
        # Later: store in Firestore with session_id
        return {
            "message": user_message,
            "session_id": session_id,
            "timestamp": self._get_timestamp(),
            "context": context
        }
    
    def _replay_message(self, user_message: str):
        """Replay user message (echo back)"""
        return (user_message or "")
    
    def _send_acknowledgement(self, user_message: str):
        """Send acknowledgement message"""
        if (user_message or "").strip().lower() == "hello":
            return "Hello â€” how can I help?"
        return "Message received and acknowledged."
    
    def _get_timestamp(self):
        """Get current timestamp"""
        return datetime.utcnow().isoformat()
